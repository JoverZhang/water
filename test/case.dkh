///////////////////////////////////////////////////////////////////////////////
// require
require diksam.lang;
require assert;

///////////////////////////////////////
//// rename
rename assert.assert assert2;

assert(true, "failed to rename function");
assert2(true, "failed to rename function");

///////////////////////////////////////////////////////////////////////////////
// function
fn fibonacci(n: int) -> int {
  if (n == 1 || n == 2) { return 1; }
  return fibonacci(n - 1) + fibonacci(n - 2);
}
fn test_function() -> void {
  test_assert(55 == fibonacci(10));

  println("success: test_function()");
}
test_function();

///////////////////////////////////////////////////////////////////////////////
// class

///////////////////////////////////////
//// method
public class Point {
  private x: int;
  private y: int;
  public constructor initialize(x: int, y: int) { this.x = x; this.y = y; }
  public fn get_x(this) -> int { return this.x; }
  public fn set_x(this, x: int) -> int { this.x = x; }
  public fn get_y(this) -> int { return this.y; }
  public fn set_y(this, y: int) -> int { this.y = y; }
  public fn to_string(this) -> string { return "Point(x = " + this.x + ", y = " + this.y + ")"; }
}
fn test_class_method() -> void {
  let point = new Point(10, 20);
  test_assert("Point(x = 10, y = 20)" == point.to_string());

  println("success: test_class_method()");
}
test_class_method();

///////////////////////////////////////
//// multi constructor
class MultiConstructorClass {
  public n: int;
  public constructor initialize() { this.n = 1; }
  public constructor initialize2() { this.n = 2; }
}
fn test_class_multi_constructor() -> void {
  test_assert(1 == new MultiConstructorClass().n);
  test_assert(2 == new MultiConstructorClass.initialize2().n);

  println("success: test_class_multi_constructor()");
}
test_class_multi_constructor();

///////////////////////////////////////
//// field init
class FieldInitClass {
  public x: int;
  public y: int = 10;
}
fn test_class_field_init() -> void {
  let o = new FieldInitClass();
  test_assert(0 == o.x);
  test_assert(10 == o.y);
  println("success: test_class_field_init()");
}
test_class_field_init();

///////////////////////////////////////
//// interface
interface ToString {
  fn to_string(this) -> string;
}
class ToStringClass : ToString {
  override
  public fn to_string(this) -> string { return "ToStringClass()"; }
}
fn test_interface() -> void {
  let o: ToString = new ToStringClass();
  test_assert("ToStringClass()" == o.to_string());

  println("success: test_interface()");
}
test_interface();

///////////////////////////////////////
//// subclass (keywords: virtual, override and super)
abstract class Parent {
  private pv: int;
  virtual
  public constructor initialize(pv: int) { this.pv = pv; }
  virtual
  public fn to_string(this) -> string { return "Parent(pv = " + this.pv + ")"; }
}

class Child : Parent {
  private cv: int;
  override
  public constructor initialize(pv: int, cv: int) { super.initialize(pv); this.cv = cv; }
  override
  public fn to_string(this) -> string { return "Child(" + super.to_string() + ", cv = " + this.cv + ")"; }
}

fn test_class_subclass() -> void {
  let child = new Child(10, 20);
  test_assert("Child(Parent(pv = 10), cv = 20)" == child.to_string());

  println("success: test_class_subclass()");
}
test_class_subclass();

///////////////////////////////////////////////////////////////////////////////
// variables
fn test_variables() -> void {
  let i = 10;
  let f = 30.2;
  let s = "Hello ";
  test_assert(40.2 == i + f);
  i = i + f;
  test_assert("Hello 40" == s + i);

  println("success: test_variables()");
}
test_variables();

///////////////////////////////////////////////////////////////////////////////
// array
fn test_array() -> void {
  let int_arr = { 1, 2, 3 };
  test_assert(3 == int_arr.size());
  test_assert(1 == int_arr[0]);
  test_assert(2 == int_arr[1]);
  test_assert(3 == int_arr[2]);

  let double_arr = { 0.1, 2, 3 };
  test_assert(3 == double_arr.size());
  test_assert(0.1 == double_arr[0]);
  test_assert(2 == double_arr[1]);
  test_assert(3 == double_arr[2]);

  let str = "Hello World";
  test_assert(11 == str.length());
  test_assert("World" == str.substr(6, 5));
  test_assert(5 == str.substr(6, 5).length());

  let p1 = new Point(10, 10);
  let p3 = new Point(30, 30);
  let point_arr = { p1, new Point(20, 20), p3 };
  test_assert(3 == point_arr.size());
  test_assert(p1 == point_arr[0]);
  test_assert(p3 == point_arr[2]);

  println("success: test_array()");
}
test_array();

///////////////////////////////////////////////////////////////////////////////
// cast
fn test_cast() -> void {
  let child = new Child(10, 20);
  let parent1: Parent = child;
  let parent2: Parent = child;
  test_assert(parent1 == parent2);

  println("success: test_cast()");
}
test_cast();

///////////////////////////////////////////////////////////////////////////////
// downcast
fn test_downcast() -> void {
  let o = new ToStringClass();
  let t: ToString = o;
  o = t.(ToStringClass);
  test_assert("ToStringClass()" == t.(ToStringClass).to_string());

  println("success: test_downcast()");
}
test_downcast();

///////////////////////////////////////////////////////////////////////////////
// instanceof
fn test_instanceof() -> void {
  let o: ToString = new ToStringClass();
  test_assert(o instanceof ToStringClass);
  // test_assert(o instanceof ToString); // always is true

  let child: Parent = new Child(10, 20);
  test_assert(child instanceof Child);
  // test_assert(child instanceof Parent); // always is true

  println("success: test_instanceof()");
}
test_instanceof();

///////////////////////////////////////////////////////////////////////////////
// delegate
delegate fn DelegateF2I(f: double) -> int;
fn f2i(f: double) -> int { return f; }
class DelegateClass {
  public f: DelegateF2I;
}
fn test_delegate() -> void {
  let f: DelegateF2I = f2i;
  test_assert(42 == f(42.2));

  let o = new DelegateClass();
  o.f = f2i;
  let g = o.f;
  test_assert(42 == g(42.2));

  println("success: test_delegate()");
}
test_delegate();

///////////////////////////////////////////////////////////////////////////////
// enum
enum Color {
  RED,
  GREEN,
  BLUE,
}
fn test_enum() -> void {
  let red = Color.RED;
  let green = Color.GREEN;
  let blue = Color.BLUE;
  test_assert(Color.RED == red);
  test_assert("RED" == "" + Color.RED);
  test_assert(red != green);
  test_assert(blue != green);

  println("success: test_enum()");
}
test_enum();

///////////////////////////////////////////////////////////////////////////////
// for loop
fn test_for_loop() -> void {
  let n = 0;
  let i: int;
  for (i = 0; i <= 100; i++) { n += i; }
  test_assert(5050 == n);

  println("success: test_for_loop()");
}
test_for_loop();

///////////////////////////////////////////////////////////////////////////////
// do while loop
fn test_while_loop() -> void {
  let n = 0; let i = 0;
  while (i <= 100) { n += i; i++; }
  test_assert(5050 == n);

  n = 0; i = 0;
  do { n += i; i++; } while (i <= 100);
  test_assert(5050 == n);

  println("success: test_while_loop()");
}
test_while_loop();

///////////////////////////////////////////////////////////////////////////////
// if
fn test_if_compare(x: int, y: int) -> int {
  if (x > y) { return 1; }
  elsif (x < y) { return -1; }
  else { return 0; }
}
fn test_if() -> void {
  test_assert(1 == test_if_compare(20, 10));
  test_assert(-1 == test_if_compare(10, 20));
  test_assert(0 == test_if_compare(10, 10));
  println("success: test_if()");
}
test_if();

///////////////////////////////////////////////////////////////////////////////
// switch
fn test_switch_color(color: Color) -> string {
  switch (color)
    case Color.RED { return "RED"; }
    case Color.GREEN { return "GREEN"; }
    case Color.BLUE { return "BLUE"; }
    default { return "NULL"; }
}
fn test_switch() -> void {
  test_switch_color(Color.RED);
  println("success: test_switch()");
}
test_switch();

///////////////////////////////////////////////////////////////////////////////
// exception
///////////////////////////////////////
//// throw exception
class TestException : Exception {}
fn test_exception_f() -> void throws Exception { throw new TestException(); }
fn test_exception() -> void {
  let n = 2;
  try {
    test_exception_f();
    test_assert(false);
  } catch (TestException e) {
    test_assert(true);
    n -= 1;
  } catch (Exception e) {
    test_assert(false);
  } finally {
    n -= 1;
  }
  test_assert(0 == n);

  println("success: test_exception()");
}
test_exception();

///////////////////////////////////////
//// throw runtime exception
class TestRuntimeException : RuntimeException {}
fn test_runtime_exception_f() -> void { throw new TestRuntimeException(); }
fn test_runtime_exception() -> void {
  let n = 2;
  try {
    test_runtime_exception_f();
    test_assert(false);
  } catch (TestRuntimeException e) {
    test_assert(true);
    n -= 1;
  } catch (RuntimeException e) {
    test_assert(false);
  } finally {
    n -= 1;
  }
  test_assert(0 == n);

  println("success: test_runtime_exception()");
}
test_runtime_exception();

///////////////////////////////////////
//// null pointer exception
fn test_null_pointer_exception() -> void {
  let n = 1;
  let o: ToStringClass;
  try {
    o.to_string();
  } catch(NullPointerException e) {
    n = 0;
  }
  test_assert(0 == n);

  println("success: test_null_pointer_exception()");
}
test_null_pointer_exception();

///////////////////////////////////////////////////////////////////////////////
// global variable
let global_i = 10;
fn test_global_variable() -> void {
  test_assert(10 == global_i);
  global_i = 20;
  test_assert(20 == global_i);

  println("success: test_global_variable()");
}
test_global_variable();

///////////////////////////////////////////////////////////////////////////////
// native pointer (File)
fn test_native_pointer() -> void {
  let fd = fopen("test/hello.txt", "r");
  let contents = new string[0];
  let str: string;
  while ((str = fgets(fd)) != null) {
    contents.add(str);
  }
  test_assert(2 == contents.size());
  test_assert("hello\n" == contents[0]);
  test_assert("world\n" == contents[1]);

  println("success: test_native_pointer()");
}
test_native_pointer();

///////////////////////////////////////////////////////////////////////////////
// native call
fn hoge(v: int) -> int { return v; }
fn test_native_call() -> void {
  test_native(hoge);

  println("success: test_native_call()");
}
test_native_call();
