fn print(str: string) -> void;
fn println(str: string) -> void {
  print(str + "\n");
}

public class File {
  fp: native_pointer;
  constructor initialize(fp: native_pointer) {
    this.fp = fp;
  }
}

fn fopen(file_name: string, mode: string) -> File;
fn fgets(file: File) -> string;
fn fputs(str: string, file: File) -> void;
fn fclose(file: File) -> void;

fn to_double(int_value: int) -> double {
  return int_value;
}

fn to_int(double_value: double) -> int {
  return double_value;
}

fn parse_int(str: string) -> int throws NumberFormatException;
fn parse_double(str: string) -> double throws NumberFormatException;

fn exit(status: int) -> void;
fn randomize() -> void;
fn random(range: int) -> int;

class StackTrace {
  line_number: int;
  file_name: string;
  function_name: string;
}

abstract public class Exception {
  public message: string;
  public stack_trace: StackTrace[];
  public fn print_stack_trace(this) -> void {
    let i: int;
    println("Exception occured. " + this.message);
    for (i = 0; i < this.stack_trace.size(); i++) {
      println("\tat "
        + this.stack_trace[i].function_name
        + "(" + this.stack_trace[i].file_name
        + ":" + this.stack_trace[i].line_number
        + ")");
    }
  }
  public virtual constructor initialize() {
    this.stack_trace = new StackTrace[0];
  }
}

abstract public class BugException : Exception {
}

abstract public class RuntimeException : Exception {
}

public class NullPointerException : BugException {
}

public class ArrayIndexOutOfBoundsException : BugException {
}

public class StringIndexOutOfBoundsException : BugException {
}

public class DivisionByZeroException : RuntimeException {
}

public class MultibyteCharacterConvertionException : RuntimeException {
}

public class ClassCastException : BugException {
}

public abstract class ApplicationException : Exception {
}

public class NumberFormatException : ApplicationException {
}

delegate fn HogeDelegate(value: int) -> int;

// BUGBUG for test routine
fn test_native(dele: HogeDelegate) -> void;

fn foo_file(file: File) -> void {
}
